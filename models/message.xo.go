package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"
)

// Message represents a row from 'public.messages'.
type Message struct {
	ID           int       `json:"id" db:"id"`                       // id
	CreatedAt    time.Time `json:"created_at" db:"created_at"`       // created_at
	UpdatedAt    time.Time `json:"updated_at" db:"updated_at"`       // updated_at
	Content      string    `json:"content" db:"content"`             // content
	AuthorID     string    `json:"author_id" db:"author_id"`         // author_id
	PodchannelID int       `json:"podchannel_id" db:"podchannel_id"` // podchannel_id
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [Message] exists in the database.
func (m *Message) Exists() bool {
	return m._exists
}

// Deleted returns true when the [Message] has been marked for deletion
// from the database.
func (m *Message) Deleted() bool {
	return m._deleted
}

// Insert inserts the [Message] to the database.
func (m *Message) Insert(ctx context.Context, db DB) error {
	switch {
	case m._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case m._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.messages (` +
		`created_at, updated_at, content, author_id, podchannel_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING id`
	// run
	logf(sqlstr, m.CreatedAt, m.UpdatedAt, m.Content, m.AuthorID, m.PodchannelID)
	if err := db.QueryRowContext(ctx, sqlstr, m.CreatedAt, m.UpdatedAt, m.Content, m.AuthorID, m.PodchannelID).Scan(&m.ID); err != nil {
		return logerror(err)
	}
	// set exists
	m._exists = true
	return nil
}

// Update updates a [Message] in the database.
func (m *Message) Update(ctx context.Context, db DB) error {
	switch {
	case !m._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case m._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.messages SET ` +
		`created_at = $1, updated_at = $2, content = $3, author_id = $4, podchannel_id = $5 ` +
		`WHERE id = $6`
	// run
	logf(sqlstr, m.CreatedAt, m.UpdatedAt, m.Content, m.AuthorID, m.PodchannelID, m.ID)
	if _, err := db.ExecContext(ctx, sqlstr, m.CreatedAt, m.UpdatedAt, m.Content, m.AuthorID, m.PodchannelID, m.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [Message] to the database.
func (m *Message) Save(ctx context.Context, db DB) error {
	if m.Exists() {
		return m.Update(ctx, db)
	}
	return m.Insert(ctx, db)
}

// Upsert performs an upsert for [Message].
func (m *Message) Upsert(ctx context.Context, db DB) error {
	switch {
	case m._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.messages (` +
		`id, created_at, updated_at, content, author_id, podchannel_id` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at, content = EXCLUDED.content, author_id = EXCLUDED.author_id, podchannel_id = EXCLUDED.podchannel_id `
	// run
	logf(sqlstr, m.ID, m.CreatedAt, m.UpdatedAt, m.Content, m.AuthorID, m.PodchannelID)
	if _, err := db.ExecContext(ctx, sqlstr, m.ID, m.CreatedAt, m.UpdatedAt, m.Content, m.AuthorID, m.PodchannelID); err != nil {
		return logerror(err)
	}
	// set exists
	m._exists = true
	return nil
}

// Delete deletes the [Message] from the database.
func (m *Message) Delete(ctx context.Context, db DB) error {
	switch {
	case !m._exists: // doesn't exist
		return nil
	case m._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.messages ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, m.ID)
	if _, err := db.ExecContext(ctx, sqlstr, m.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	m._deleted = true
	return nil
}

// MessagesByAuthorID retrieves a row from 'public.messages' as a [Message].
//
// Generated from index 'idx_messages_author_id'.
func MessagesByAuthorID(ctx context.Context, db DB, authorID string) ([]*Message, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, created_at, updated_at, content, author_id, podchannel_id ` +
		`FROM public.messages ` +
		`WHERE author_id = $1`
	// run
	logf(sqlstr, authorID)
	rows, err := db.QueryContext(ctx, sqlstr, authorID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Message
	for rows.Next() {
		m := Message{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&m.ID, &m.CreatedAt, &m.UpdatedAt, &m.Content, &m.AuthorID, &m.PodchannelID); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &m)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// MessagesByPodchannelID retrieves a row from 'public.messages' as a [Message].
//
// Generated from index 'idx_messages_podchannel_id'.
func MessagesByPodchannelID(ctx context.Context, db DB, podchannelID int) ([]*Message, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, created_at, updated_at, content, author_id, podchannel_id ` +
		`FROM public.messages ` +
		`WHERE podchannel_id = $1`
	// run
	logf(sqlstr, podchannelID)
	rows, err := db.QueryContext(ctx, sqlstr, podchannelID)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// process
	var res []*Message
	for rows.Next() {
		m := Message{
			_exists: true,
		}
		// scan
		if err := rows.Scan(&m.ID, &m.CreatedAt, &m.UpdatedAt, &m.Content, &m.AuthorID, &m.PodchannelID); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &m)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// MessageByID retrieves a row from 'public.messages' as a [Message].
//
// Generated from index 'messages_pkey'.
func MessageByID(ctx context.Context, db DB, id int) (*Message, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, created_at, updated_at, content, author_id, podchannel_id ` +
		`FROM public.messages ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	m := Message{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&m.ID, &m.CreatedAt, &m.UpdatedAt, &m.Content, &m.AuthorID, &m.PodchannelID); err != nil {
		return nil, logerror(err)
	}
	return &m, nil
}

// Podchannel returns the Podchannel associated with the [Message]'s (PodchannelID).
//
// Generated from foreign key 'messages_podchannel_id_fkey'.
func (m *Message) Podchannel(ctx context.Context, db DB) (*Podchannel, error) {
	return PodchannelByID(ctx, db, m.PodchannelID)
}
